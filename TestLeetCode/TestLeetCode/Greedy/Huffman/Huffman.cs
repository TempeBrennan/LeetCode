
using System;
using System.Collections;
using System.Collections.Generic;

class HuffmanNode
{
    public int Data;
    public string Character;
    public HuffmanNode Left;
    public HuffmanNode Right;
    public HuffmanNode()
    {
        this.Data = 0;
        this.Character = "";
        this.Left = this.Right = null;
    }
}

public class Huffuman
{
    void PrintCode(HuffmanNode root, string str)
    {
        // base case; if the left and right are null
        // then its a leaf node and we print
        // the code s generated by traversing the tree.
        if (root.Left == null
            && root.Right == null
            && (root.Character).ToLower() != (root.Character).ToUpper())
        {

            // c is the character in the node
            Console.WriteLine(root.Character + ":" + str);

            return;
        }

        // if we go to left then add "0" to the code.
        // if we go to the right add"1" to the code.

        // recursive calls for left and
        // right sub-tree of the generated tree.
        PrintCode(root.Left, str + "0");
        PrintCode(root.Right, str + "1");
    }
    public void Main()
    {
        // main function
        // number of characters.
        var n = 6;
        var charArray = new string[] { "a", "b", "c", "d", "e", "f" };
        var charfreq = new int[] { 5, 9, 12, 13, 16, 45 };

        // creating a priority queue q.
        // makes a min-priority queue(min-heap).
        var q = new List<HuffmanNode>();

        for (var i = 0; i < n; i++)
        {

            // creating a Huffman node object
            // and add it to the priority queue.
            var hn = new HuffmanNode();

            hn.Character = charArray[i];
            hn.Data = charfreq[i];

            hn.Left = null;
            hn.Right = null;

            // add functions adds
            // the huffman node to the queue.
            q.Add(hn);
        }

        // create a root node
        HuffmanNode root = null;
        //q.sort(function(a, b){ return a.data - b.data; });

        // Here we will extract the two minimum value
        // from the heap each time until
        // its size reduces to 1, extract until
        // all the nodes are extracted.
        while (q.Count > 1)
        {

            // first min extract.
            var x = q[0];
            q.RemoveAt(q.Count - 1);

            // second min extract.
            var y = q[0];
            q.RemoveAt(q.Count - 1);

            // new node f which is equal
            var f = new HuffmanNode();

            // to the sum of the frequency of the two nodes
            // assigning values to the f node.
            f.Data = x.Data + y.Data;
            f.Character = "-";

            // first extracted node as left child.
            f.Left = x;

            // second extracted node as the right child.
            f.Right = y;

            // marking the f node as the root node.
            root = f;

            // add this node to the priority-queue.
            q.Add(f);
            q.Sort(new Comparer());
        }

        // print the codes by traversing the tree
        PrintCode(root, "");
    }
}

class Comparer : IComparer<HuffmanNode>
{
    public int Compare(HuffmanNode x, HuffmanNode y)
    {
        return x.Data - y.Data;
    }
}